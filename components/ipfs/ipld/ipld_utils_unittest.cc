/* Copyright (c) 2024 The Brave Authors. All rights reserved.
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at https://mozilla.org/MPL/2.0/. */

#include "brave/components/ipfs/ipld/ipld_utils.h"
#include <algorithm>


#include "base/containers/contains.h"
#include "base/strings/string_number_conversions.h"
#include "base/strings/string_util.h"
#include "gtest/gtest.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "base/logging.h"

namespace {
    //Header of the CAR file (base32 - cidv1 - dag-cbor - (sha2-256 : 256 : F88BC853804CF294FE417E4FA83028689FCDB1B1592C5102E1474DBC200FAB8B))
    // version: 1, roots: bafyreihyrpefhacm6kkp4ql6j6udakdit7g3dmkzfriqfykhjw6cad5lrm, bafyreidj5idub6mapiupjwjsyyxhyhedxycv4vihfsicm2vt46o7morwlm
    const std::vector<uint8_t> kCarv1HeaderData = {
    0xA2, 0x65, 0x72, 0x6F, 0x6F, 0x74, 0x73, 0x82, 0xD8, 0x2A, 0x58, 0x25, 0x00, 0x01, 0x71, 0x12, 
    0x20, 0xF8, 0x8B, 0xC8, 0x53, 0x80, 0x4C, 0xF2, 0x94, 0xFE, 0x41, 0x7E, 0x4F, 0xA8, 0x30, 0x28, 
    0x68, 0x9F, 0xCD, 0xB1, 0xB1, 0x59, 0x2C, 0x51, 0x02, 0xE1, 0x47, 0x4D, 0xBC, 0x20, 0x0F, 0xAB, 
    0x8B, 0xD8, 0x2A, 0x58, 0x25, 0x00, 0x01, 0x71, 0x12, 0x20, 0x69, 0xEA, 0x07, 0x40, 0xF9, 0x80, 
    0x7A, 0x28, 0xF4, 0xD9, 0x32, 0xC6, 0x2E, 0x7C, 0x1C, 0x83, 0xBE, 0x05, 0x5E, 0x55, 0x07, 0x2C, 
    0x90, 0x26, 0x6A, 0xB3, 0xE7, 0x9D, 0xF6, 0x3A, 0x36, 0x5B, 0x67, 0x76, 0x65, 0x72, 0x73, 0x69, 
    0x6F, 0x6E, 0x01//, 0x5B
    };

    //Pragma for the CAR_V2
    const std::vector<uint8_t> kCarv2HeaderPragmaData = {
    0x0A, 0xA1, 0x67, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x02
    };

    const std::vector<uint8_t> kCarv2HeaderAndPragmaData = {
        0x0A, 0xA1, 0x67, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x01, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00
    };

    const std::vector<uint8_t> kDagPbCarBlock1Data = {
        0x01, 0x71, 0x12, 0x20, 0xF8, 0x8B, 0xC8, 0x53, 0x80, 0x4C, 0xF2, 0x94, 0xFE, 0x41, 0x7E, 0x4F, 
        0xA8, 0x30, 0x28, 0x68, 0x9F, 0xCD, 0xB1, 0xB1, 0x59, 0x2C, 0x51, 0x02, 0xE1, 0x47, 0x4D, 0xBC, 
        0x20, 0x0F, 0xAB, 0x8B, 0xA2, 0x64, 0x6C, 0x69, 0x6E, 0x6B, 0xD8, 0x2A, 0x58, 0x23, 0x00, 0x12, 
        0x20, 0x02, 0xAC, 0xEC, 0xC5, 0xDE, 0x24, 0x38, 0xEA, 0x41, 0x26, 0xA3, 0x01, 0x0E, 0xCB, 0x1F, 
        0x8A, 0x59, 0x9C, 0x8E, 0xFF, 0x22, 0xFF, 0xF1, 0xA1, 0xDC, 0xFF, 0xE9, 0x99, 0xB2, 0x7F, 0xD3, 
        0xDE, 0x64, 0x6E, 0x61, 0x6D, 0x65, 0x64, 0x62, 0x6C, 0x69, 0x70
    };

    const std::vector<uint8_t> kDagPbCarBlock2Data = {
        0x12, 0x20, 0x02, 0xAC, 0xEC, 0xC5, 0xDE, 0x24, 0x38, 0xEA, 0x41, 0x26, 0xA3, 0x01, 0x0E, 
        0xCB, 0x1F, 0x8A, 0x59, 0x9C, 0x8E, 0xFF, 0x22, 0xFF, 0xF1, 0xA1, 0xDC, 0xFF, 0xE9, 0x99, 0xB2, 
        0x7F, 0xD3, 0xDE, 0x12, 0x2E, 0x0A, 0x24, 0x01, 0x55, 0x12, 0x20, 0xB6, 0xFB, 0xD6, 0x75, 0xF9, 
        0x8E, 0x2A, 0xBD, 0x22, 0xD4, 0xED, 0x29, 0xFD, 0xC8, 0x31, 0x50, 0xFE, 0xDC, 0x48, 0x59, 0x7E, 
        0x92, 0xDD, 0x1A, 0x7A, 0x24, 0x38, 0x1D, 0x44, 0xA2, 0x74, 0x51, 0x12, 0x04, 0x62, 0x65, 0x61, 
        0x72, 0x18, 0x04, 0x12, 0x2F, 0x0A, 0x22, 0x12, 0x20, 0x79, 0xA9, 0x82, 0xDE, 0x3C, 0x99, 0x07, 
        0x95, 0x3D, 0x4D, 0x32, 0x3C, 0xEE, 0x1D, 0x0F, 0xB1, 0xED, 0x8F, 0x45, 0xF8, 0xEF, 0x02, 0x87, 
        0x0C, 0x0C, 0xB9, 0xE0, 0x92, 0x46, 0xBD, 0x53, 0x0A, 0x12, 0x06, 0x73, 0x65, 0x63, 0x6F, 0x6E, 
        0x64, 0x18, 0x95, 0x01
    };

    const std::vector<uint8_t> kDagPbCarBlock3Data = {
        0x01, 0x55, 0x12, 0x20, 0xB6, 0xFB, 0xD6, 0x75, 0xF9, 0x8E, 0x2A, 0xBD, 0x22, 0xD4, 0xED, 0x29, 
        0xFD, 0xC8, 0x31, 0x50, 0xFE, 0xDC, 0x48, 0x59, 0x7E, 0x92, 0xDD, 0x1A, 0x7A, 0x24, 0x38, 0x1D, 
        0x44, 0xA2, 0x74, 0x51, 0x63, 0x63, 0x63, 0x63
    };

    const std::vector<uint8_t> kDagPbCarBlock4Data = {
        0x12, 0x20, 0x79, 0xA9, 0x82, 0xDE, 0x3C, 0x99, 0x07, 0x95, 0x3D, 0x4D, 0x32, 0x3C, 0xEE, 
        0x1D, 0x0F, 0xB1, 0xED, 0x8F, 0x45, 0xF8, 0xEF, 0x02, 0x87, 0x0C, 0x0C, 0xB9, 0xE0, 0x92, 0x46, 
        0xBD, 0x53, 0x0A, 0x12, 0x2D, 0x0A, 0x24, 0x01, 0x55, 0x12, 0x20, 0x81, 0xCC, 0x5B, 0x17, 0x01, 
        0x86, 0x74, 0xB4, 0x01, 0xB4, 0x2F, 0x35, 0xBA, 0x07, 0xBB, 0x79, 0xE2, 0x11, 0x23, 0x9C, 0x23, 
        0xBF, 0xFE, 0x65, 0x8D, 0xA1, 0x57, 0x7E, 0x3E, 0x64, 0x68, 0x77, 0x12, 0x03, 0x64, 0x6F, 0x67, 
        0x18, 0x04, 0x12, 0x2D, 0x0A, 0x22, 0x12, 0x20, 0xE7, 0xDC, 0x48, 0x6E, 0x97, 0xE6, 0xEB, 0xE5, 
        0xCD, 0xAB, 0xAB, 0x3E, 0x39, 0x2B, 0xDA, 0xD1, 0x28, 0xB6, 0xE0, 0x9A, 0xCC, 0x94, 0xBB, 0x4E, 
        0x2A, 0xA2, 0xAF, 0x7B, 0x98, 0x6D, 0x24, 0xD0, 0x12, 0x05, 0x66, 0x69, 0x72, 0x73, 0x74, 0x18, 
        0x33
    };

    const std::vector<uint8_t> kDagPbCarBlock5Data = {
        0x01, 0x55, 0x12, 0x20, 0x81, 0xCC, 0x5B, 0x17, 0x01, 0x86, 0x74, 0xB4, 0x01, 0xB4, 0x2F, 0x35, 
        0xBA, 0x07, 0xBB, 0x79, 0xE2, 0x11, 0x23, 0x9C, 0x23, 0xBF, 0xFE, 0x65, 0x8D, 0xA1, 0x57, 0x7E, 
        0x3E, 0x64, 0x68, 0x77, 0x62, 0x62, 0x62, 0x62
    };
}

class IpldUtilsUnitTest : public testing::Test {
 public:
  IpldUtilsUnitTest() = default;
  ~IpldUtilsUnitTest() override = default;

};

TEST_F(IpldUtilsUnitTest, DecodeCarv1Header) {
    // Valid CAR_V1 header
    auto result = ipfs::ipld::decode_carv1_header(kCarv1HeaderData);
    ASSERT_EQ(result.error.error.length(), 0UL);
    ASSERT_EQ(result.error.error_code, 0);
    ASSERT_EQ(result.data.version, 1UL);
    ASSERT_EQ(result.data.roots.size(), 2UL);
    ASSERT_TRUE(base::Contains(result.data.roots, "bafyreihyrpefhacm6kkp4ql6j6udakdit7g3dmkzfriqfykhjw6cad5lrm"));
    ASSERT_TRUE(base::Contains(result.data.roots, "bafyreidj5idub6mapiupjwjsyyxhyhedxycv4vihfsicm2vt46o7morwlm"));

    // Valid CAR_V1 header, wrong version. Changed version to 2 (offset 98)
    std::vector<uint8_t> carv1_header_data(kCarv1HeaderData); carv1_header_data[98] = 0x02;
    result = ipfs::ipld::decode_carv1_header(carv1_header_data);
    ASSERT_GT(result.error.error.length(), 0UL);
    ASSERT_EQ(result.error.error_code, 30);
    ASSERT_EQ(result.data.version, 2UL);
    ASSERT_EQ(result.data.roots.size(), 0UL);

    // Valid CAR_V2 pragma (11 bytes)
    result = ipfs::ipld::decode_carv1_header(kCarv2HeaderPragmaData);
    ASSERT_GT(result.error.error.length(), 0UL);
    ASSERT_EQ(result.error.error_code, 10);

    // Valid CAR_V2 pragma data (10 bytes, without length)
    std::vector<uint8_t> carv2_header_pragme_data(kCarv2HeaderPragmaData); carv2_header_pragme_data.erase(carv2_header_pragme_data.cbegin());
    result = ipfs::ipld::decode_carv1_header(carv2_header_pragme_data);
    ASSERT_GT(result.error.error.length(), 0UL);
    ASSERT_EQ(result.error.error_code, 30);
    ASSERT_EQ(result.data.version, 2UL);
    ASSERT_EQ(result.data.roots.size(), 0UL);
}

TEST_F(IpldUtilsUnitTest, DecodeCarv2Header) {
    // Valid CAR_V2 header
    auto result = ipfs::ipld::decode_carv2_header(kCarv2HeaderAndPragmaData);    
    ASSERT_EQ(result.error.error.length(), 0UL);
    ASSERT_EQ(result.error.error_code, 0);
    ASSERT_EQ(result.data.data_offset, 51UL);
    ASSERT_EQ(result.data.data_size, 448UL);
    ASSERT_EQ(result.data.index_offset, 499UL);
    ASSERT_EQ(result.data.characteristics.data[0], 144115188075855872UL);
    ASSERT_EQ(result.data.characteristics.data[1], 144115188075855872UL);


   if(result.error.error.length() > 0) {
        LOG(INFO) << "Error: " << std::string(result.error.error.data(), result.error.error.length());
    } else {
        LOG(INFO) << "Header data_offset:" << result.data.data_offset << " data_size: " << result.data.data_size << "index_offset" << result.data.index_offset;
        LOG(INFO) << "characteristics[0]:" << result.data.characteristics.data[0] << "characteristics[1]:" << result.data.characteristics.data[1];
        // for(const auto& item : result.data.data.roots) {
        //     LOG(INFO) << std::string(item.data(), item.length());
        // }
    }
}

TEST_F(IpldUtilsUnitTest, DecodeDagCbor) {
    uint64_t offset = 100;
    auto result = ipfs::ipld::decode(offset, kDagPbCarBlock1Data);
    ASSERT_EQ(result.error.error.length(), 0UL);
    ASSERT_FALSE(result.is_block_data);
    
    result = ipfs::ipld::decode(result.data_offset, kDagPbCarBlock2Data);
    ASSERT_EQ(result.error.error.length(), 0UL);
    ASSERT_FALSE(result.is_block_data);

    result = ipfs::ipld::decode(result.data_offset, kDagPbCarBlock3Data);
    ASSERT_EQ(result.error.error.length(), 0UL);
    ASSERT_TRUE(result.is_block_data);

    result = ipfs::ipld::decode(result.data_offset, kDagPbCarBlock4Data);
    ASSERT_EQ(result.error.error.length(), 0UL);
    ASSERT_FALSE(result.is_block_data);

    result = ipfs::ipld::decode(result.data_offset, kDagPbCarBlock5Data);
    ASSERT_EQ(result.error.error.length(), 0UL);
    ASSERT_TRUE(result.is_block_data);

    if(result.error.error.length() > 0) {
        LOG(INFO) << "Error: " << result.error.error.c_str();
    } else {
        LOG(INFO) << "Cid:" << result.cid.c_str()
                  << "\r\ndata_offset:" << result.data_offset                  
                  ;
        std::stringstream _ss;
        for(const auto& item : result.data) {
            _ss << item;
        }
        LOG(INFO) << "result.data:" << _ss.str();
    }
}